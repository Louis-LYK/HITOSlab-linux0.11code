-3.1. 进程创建过程

在C语言里，通过fork()创建一个进程，在linux内核中，由fork.c里的copy_process()完成创建，系统做以下三件事：

(1)	首先申请一个空的task_struct内存空间；

(2)	把该PCB的指针加入task[ ]数组；

(3) 向PCB写入基本信息，如进程状态，进程ID，分配的时间片，signal，alarm,priority等；

![login](https://github.com/Louis-LYK/myOSlab/blob/main/copy_process.png) ![login](https://github.com/Louis-LYK/myOSlab/blob/main/tss.png)

如图可知，新进程创建后只是更新了esp0和ss0这俩内核栈内容，其他的基本都copy原来父进程寄存器里的内容，这也是为啥有时候fork出来的子进程还会printf出跟父进程一模一样内容的原因。因为子进程CS寄存器的内容也是从老爹那copy过来的。

-3.2.TSS

再往下有tss，tss（task state segment）叫做任务状态段，专门为进/线程切换设计的，它有自己结构体，叫做tss描述符表，在最初的linux0.11，进行任务切换的时候，CPU将寄存器的内容保存在当前任务寄存器指向的TSS表里，然后将新TSS里的内容写入当前寄存器中，这样就实现了进程切换。
通过linux-0.12可以看到，新创建的进程确实如函数名（copy_process()）所言，把父进程寄存器的内容copy到了新进程的TSS里去了。


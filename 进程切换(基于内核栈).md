（上一节讲了进程调度和进程切换的原理，但是进程切换过程还只是个黑箱，本节将剖析切换的过程和原理。上节说过基于TSS的切换和基于内核栈的切换，实际上前者已经是历史了，本节就是聚焦基于内核栈的切换
方式。）

- 4.1.进程与线程

Linux里进程和线程没有太多区别，linux没有对进程和线程分别做抽象，在linux-0.12里的struct task_struct结构就存储进程、线程的信息，这个task_struct就是用来表示PCB或TCB的，它也叫做进程描述符，进
程控制块PCB是系统为管理进程专门设立的独立数据结构。

进程拥有自己独立的内存空间，然而线程没有，系统不给线程分配内存，线程只能使用它所属的进程的内存资源，线程组只能共享内部资源，那么task_struct如何区分进程与线程？即当两个task_struct不共享任何资
源，那么它们就被视为2个进程，相反，若共享所有资源，那就被视为进程下的2个线程，进程切换比线程切换，也就多一个地址映射表，属于内存管理的知识。

事实上，CPU上实际运行的就是一个个线程。 

![login](https://github.com/Louis-LYK/myOSlab/blob/main/thread.png)   ![login](https://github.com/Louis-LYK/myOSlab/blob/main/thread1.png)

在task_struct（在linux-0.11/include/linux/sched.h）里，task_struct除了保存该进程的基本信息，还保存着各个资源对象的指针（它并不直接保存这些资源本身，那些占用空间很大,这也是1个task_struct只有十几KB大小的原因），比如文件系统相关的指针，TSS的引用，内存管理的相关信息等。

- 4.2.堆栈概念在用户态和内核态的区分

每一个进程/线程（用户级/内核级）的地址空间都分为用户地址空间和内核地址空间两部分。

对于内核进程，由于始终运行在内核态，所以没有用户地址空间，其task_struct对应的mm被赋值为null。

“堆“的概念只存在于用户地址空间种，因此内核进程没有“堆”一说，然后内核进程可以用kmalloc或vmalloc申请内存，且这块内存在整个内核空间都能使用，比如内核线程1申请一块A，内核线程2也可以使用这块A内存，不过这不叫“堆”了。

总结

用户进程：有自己的用户态堆，用户态栈，内核态栈；

内核进程：只有内核态栈；

